/*
 * Copyright 2018 Loopring Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_multiple_files = true;
package org.loopring.lightcone.proto;

import "common.proto";
import "core.proto";
import "actors_data.proto";
import "ethereum.proto";

/////////////////////////////////////////////////////////////////////
// TWO WAY DATABASE-RELATED REQUEST-RESPONSES
/////////////////////////////////////////////////////////////////////

message PersistOrder {
    message Req {
        RawOrder order    = 1;
    }
    message Res {
        RawOrder order    = 1;
        bool already_exist      = 2;
        ErrorCode error = 3;
    }
}

message UpdateOrderState {
    message Req {
        string hash = 1;
        RawOrder.State state = 2;
        bool changeUpdatedAtField = 3;
    }

    message Res {
        ErrorCode error = 1;
    }
}

message UpdateOrderStatus {
    message Req {
        string hash = 1;
        OrderStatus status = 2;
        bool changeUpdatedAtField = 3;
    }

    message Res {
        ErrorCode error = 1;
}
}

message GetOrderByHash {
    message Req {
        string hash = 1;
    }

    message Res {
        RawOrder order = 1;
        ErrorCode error = 2;
    }

    message BatchReq {
        repeated string hashes = 1;
    }

    message BatchRes {
        repeated RawOrder orders = 1;
        ErrorCode error = 2;
    }
}


message GetOrdersForUser {
    message Req {
        oneof market {
            MarketPair pair        = 1; // tokenS -> tokenB
            string     market_hash = 2; // tokenS -> tokenB && tokenB -> tokenS
        }
        string   owner                 = 3;
        repeated OrderStatus statuses = 4;
        SortingType    sort                  = 5;
        Paging    skip                  = 6;
    }

    message Res {
        repeated RawOrder orders = 1;
        ErrorCode error = 2;
    }
}

message UserCancelOrder {
    message Req {
        repeated string order_hashes = 1;
    }

    message Res {
        message Result {
            string    order_hash = 1;
            RawOrder  order      = 2;
            ErrorCode error      = 3;
        }
        repeated Result updated_result = 1;
    }
}

message GetTrades {
    message Req {
        oneof market {
            MarketPair pair        = 1; // tokenS -> tokenB
            string     market_hash = 2; // tokenS -> tokenB && tokenB -> tokenS
        }
        string owner   = 3;
        SortingType sort     = 4;
        Paging skip     = 5;
    }

    message Res {
        repeated Trade  trades = 1;
        ErrorCode       error  = 2;
    }
}

message PersistSettlementTx {
    message Req {
        SettlementTx tx = 1;
    }

    message Res {
        ErrorCode error = 1;
    }
}

message GetPendingTxs {
    message Req {
        string owner       = 1; // required
        int64  time_before = 2; // create_at <= time_before
    }

    message Res {
        repeated SettlementTx txs = 1;
    }
}

message UpdateTxInBlock {
    message Req {
        string tx_hash = 1;
        string from    = 2;
        int64  nonce   = 3;
    }

    message Res {
        ErrorCode error = 1;
    }
}

message BlockchainRecordData {
    enum RecordType {
        TRANSFER        = 0;
        ERC20_TRANSFER  = 1;
        ORDER_FILLED    = 2;
        ORDER_CANCELLED = 3;
    }
    EventHeader header      = 1;
    string      owner       = 2;
    RecordType  record_type = 3;
    int64       created_at  = 4;
    bytes       event_data  = 5;

//    oneof event_data {
//        TransferEvent        transfer = 101;
//        OrdersCancelledEvent orderCancelled = 102;
//        CutoffEvent          cutoff = 103;
//        OrderFilledEvent     filled = 104;
//    }
}

message TransferData {
    EventHeader   header      = 1;
    string        owner       = 2;
    int64         created_at  = 3;
    TransferEvent serialized  = 4;
}

message ERC20TransferData {
    EventHeader   header      = 1;
    string        owner       = 2;
    string        from        = 3;
    string        to          = 4;
    string        token       = 5;
    int64         created_at  = 6;
    TransferEvent serialized  = 7;
}

message OrderCancelledData {
    EventHeader          header      = 1;
    string               broker      = 2;
    string               owner       = 3;
    string               order_hash  = 4;
    string               market      = 5;
    string               market_hash = 6;
    int64                created_at  = 7;
    OrdersCancelledEvent serialized  = 8;
}

//market,tokens,tokenb,side,ringIndex,ringHash
message OrderFilledData {
    EventHeader       header      = 1;
    string            owner       = 2;
    string            order_hash  = 3;
    string            market      = 4;
    string            market_hash = 5;
    string            token_b     = 6;
    string            token_s     = 7;
    int32             is_buy      = 8; // 1:buy 0:sell for market value
    int64             ring_index  = 9;
    string            ring_hash   = 10;
    int64             created_at  = 11;
    OrderFilledEvent  serialized  = 12;
}

message PersistBlockchainRecord {
    message Req {
        BlockchainRecordData data    = 1;
    }
    message Res {
        BlockchainRecordData data          = 1;
        bool                 already_exist = 2;
        ErrorCode            error         = 3;
    }
}